import { WorkflowStep, SkillType } from './workflow-engine';
import PDFDocument from 'pdfkit';
import { createWriteStream } from 'fs';
import { join } from 'path';

/**
 * Deliverable Generator Service
 * 
 * Generates professional deliverables (PDFs, Excel, etc.) for workflow steps
 */

export interface DeliverableConfig {
  workflowId: string;
  stepId: string;
  skillType: SkillType;
  stepName: string;
  deliverableType: string;
  data: Record<string, any>;
  metadata?: Record<string, any>;
}

export interface GeneratedDeliverable {
  filename: string;
  filepath: string;
  url: string;
  type: string;
  size: number;
  createdAt: Date;
}

export class DeliverableGenerator {
  private static outputDir = '/tmp/deliverables';

  /**
   * Generate deliverable for a workflow step
   */
  static async generateDeliverable(
    config: DeliverableConfig
  ): Promise<GeneratedDeliverable> {
    const { skillType, deliverableType } = config;

    // Route to appropriate generator based on deliverable type
    if (deliverableType.includes('Report')) {
      return this.generateReport(config);
    } else if (deliverableType.includes('Spreadsheet') || deliverableType.includes('Model')) {
      return this.generateSpreadsheet(config);
    } else if (deliverableType.includes('Canvas') || deliverableType.includes('Matrix')) {
      return this.generateCanvas(config);
    } else if (deliverableType.includes('Document')) {
      return this.generateDocument(config);
    } else {
      // Default to PDF report
      return this.generateReport(config);
    }
  }

  /**
   * Generate PDF Report
   */
  private static async generateReport(
    config: DeliverableConfig
  ): Promise<GeneratedDeliverable> {
    const filename = `${config.deliverableType.replace(/\s+/g, '_')}_${Date.now()}.pdf`;
    const filepath = join(this.outputDir, filename);

    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({
        size: 'LETTER',
        margins: { top: 50, bottom: 50, left: 50, right: 50 },
      });

      const stream = createWriteStream(filepath);
      doc.pipe(stream);

      // Header
      doc
        .fontSize(24)
        .font('Helvetica-Bold')
        .text(config.deliverableType, { align: 'center' })
        .moveDown();

      // Metadata
      doc
        .fontSize(10)
        .font('Helvetica')
        .text(`Generated: ${new Date().toLocaleDateString()}`, { align: 'center' })
        .text(`Workflow: ${config.workflowId}`, { align: 'center' })
        .text(`Step: ${config.stepName}`, { align: 'center' })
        .moveDown(2);

      // Content based on skill type
      this.addReportContent(doc, config);

      // Footer
      doc
        .fontSize(8)
        .text(
          `Generated by CEPHO.AI - ${new Date().toISOString()}`,
          50,
          doc.page.height - 50,
          { align: 'center' }
        );

      doc.end();

      stream.on('finish', () => {
        resolve({
          filename,
          filepath,
          url: `/api/deliverables/${filename}`,
          type: 'application/pdf',
          size: 0, // FUTURE: Calculate actual file size
          createdAt: new Date(),
        });
      });

      stream.on('error', reject);
    });
  }

  /**
   * Add content to PDF report based on skill type
   */
  private static addReportContent(doc: PDFKit.PDFDocument, config: DeliverableConfig) {
    const { skillType, stepName, data } = config;

    doc.fontSize(14).font('Helvetica-Bold').text('Executive Summary').moveDown(0.5);

    switch (skillType) {
      case 'project_genesis':
        this.addProjectGenesisContent(doc, stepName, data);
        break;
      case 'ai_sme':
        this.addAISMEContent(doc, stepName, data);
        break;
      case 'quality_gates':
        this.addQualityGatesContent(doc, stepName, data);
        break;
      case 'due_diligence':
        this.addDueDiligenceContent(doc, stepName, data);
        break;
      case 'financial_modeling':
        this.addFinancialModelingContent(doc, stepName, data);
        break;
      case 'data_room':
        this.addDataRoomContent(doc, stepName, data);
        break;
      case 'digital_twin':
        this.addDigitalTwinContent(doc, stepName, data);
        break;
    }
  }

  private static addProjectGenesisContent(
    doc: PDFKit.PDFDocument,
    stepName: string,
    data: Record<string, any>
  ) {
    doc
      .fontSize(12)
      .font('Helvetica')
      .text(`This report summarizes the findings and recommendations from the ${stepName} step.`)
      .moveDown();

    // Add data sections
    if (data.summary) {
      doc.fontSize(12).font('Helvetica-Bold').text('Summary').moveDown(0.5);
      doc.fontSize(11).font('Helvetica').text(data.summary).moveDown();
    }

    if (data.findings) {
      doc.fontSize(12).font('Helvetica-Bold').text('Key Findings').moveDown(0.5);
      data.findings.forEach((finding: string, index: number) => {
        doc.fontSize(11).font('Helvetica').text(`${index + 1}. ${finding}`).moveDown(0.3);
      });
      doc.moveDown();
    }

    if (data.recommendations) {
      doc.fontSize(12).font('Helvetica-Bold').text('Recommendations').moveDown(0.5);
      data.recommendations.forEach((rec: string, index: number) => {
        doc.fontSize(11).font('Helvetica').text(`${index + 1}. ${rec}`).moveDown(0.3);
      });
      doc.moveDown();
    }

    if (data.nextSteps) {
      doc.fontSize(12).font('Helvetica-Bold').text('Next Steps').moveDown(0.5);
      data.nextSteps.forEach((step: string, index: number) => {
        doc.fontSize(11).font('Helvetica').text(`${index + 1}. ${step}`).moveDown(0.3);
      });
    }
  }

  private static addAISMEContent(
    doc: PDFKit.PDFDocument,
    stepName: string,
    data: Record<string, any>
  ) {
    doc
      .fontSize(12)
      .font('Helvetica')
      .text('AI-SME Consultation Report')
      .moveDown();

    if (data.experts) {
      doc.fontSize(12).font('Helvetica-Bold').text('Expert Panel').moveDown(0.5);
      data.experts.forEach((expert: any) => {
        doc
          .fontSize(11)
          .font('Helvetica-Bold')
          .text(expert.name)
          .font('Helvetica')
          .text(expert.title)
          .text(expert.specialization)
          .moveDown(0.5);
      });
      doc.moveDown();
    }

    if (data.question) {
      doc.fontSize(12).font('Helvetica-Bold').text('Question').moveDown(0.5);
      doc.fontSize(11).font('Helvetica').text(data.question).moveDown();
    }

    if (data.insights) {
      doc.fontSize(12).font('Helvetica-Bold').text('Expert Insights').moveDown(0.5);
      data.insights.forEach((insight: any) => {
        doc
          .fontSize(11)
          .font('Helvetica-Bold')
          .text(`${insight.expert}:`)
          .font('Helvetica')
          .text(insight.response)
          .moveDown(0.5);
      });
    }
  }

  private static addQualityGatesContent(
    doc: PDFKit.PDFDocument,
    stepName: string,
    data: Record<string, any>
  ) {
    doc
      .fontSize(12)
      .font('Helvetica')
      .text('Quality Gate Validation Report')
      .moveDown();

    if (data.criteria) {
      doc.fontSize(12).font('Helvetica-Bold').text('Quality Criteria').moveDown(0.5);
      data.criteria.forEach((criterion: any) => {
        doc
          .fontSize(11)
          .font('Helvetica')
          .text(`${criterion.name}: ${criterion.status}`)
          .text(`  Score: ${criterion.score}/${criterion.maxScore}`)
          .moveDown(0.3);
      });
      doc.moveDown();
    }

    if (data.overallScore) {
      doc
        .fontSize(12)
        .font('Helvetica-Bold')
        .text(`Overall Score: ${data.overallScore}%`)
        .moveDown();
    }

    if (data.passed !== undefined) {
      doc
        .fontSize(12)
        .font('Helvetica-Bold')
        .fillColor(data.passed ? 'green' : 'red')
        .text(data.passed ? 'PASSED' : 'FAILED')
        .fillColor('black')
        .moveDown();
    }
  }

  private static addDueDiligenceContent(
    doc: PDFKit.PDFDocument,
    stepName: string,
    data: Record<string, any>
  ) {
    doc
      .fontSize(12)
      .font('Helvetica')
      .text('Due Diligence Report')
      .moveDown();

    if (data.risks) {
      doc.fontSize(12).font('Helvetica-Bold').text('Risk Assessment').moveDown(0.5);
      data.risks.forEach((risk: any) => {
        doc
          .fontSize(11)
          .font('Helvetica-Bold')
          .text(`${risk.category}: ${risk.severity}`)
          .font('Helvetica')
          .text(risk.description)
          .text(`Mitigation: ${risk.mitigation}`)
          .moveDown(0.5);
      });
    }
  }

  private static addFinancialModelingContent(
    doc: PDFKit.PDFDocument,
    stepName: string,
    data: Record<string, any>
  ) {
    doc
      .fontSize(12)
      .font('Helvetica')
      .text('Financial Model Summary')
      .moveDown();

    if (data.scenarios) {
      doc.fontSize(12).font('Helvetica-Bold').text('Scenario Analysis').moveDown(0.5);
      data.scenarios.forEach((scenario: any) => {
        doc
          .fontSize(11)
          .font('Helvetica-Bold')
          .text(scenario.name)
          .font('Helvetica')
          .text(`Revenue: $${scenario.revenue}M`)
          .text(`EBITDA: $${scenario.ebitda}M`)
          .text(`Margin: ${scenario.margin}%`)
          .moveDown(0.5);
      });
    }
  }

  private static addDataRoomContent(
    doc: PDFKit.PDFDocument,
    stepName: string,
    data: Record<string, any>
  ) {
    doc
      .fontSize(12)
      .font('Helvetica')
      .text('Data Room Summary')
      .moveDown();

    if (data.documents) {
      doc.fontSize(12).font('Helvetica-Bold').text('Document Inventory').moveDown(0.5);
      doc
        .fontSize(11)
        .font('Helvetica')
        .text(`Total Documents: ${data.documents.length}`)
        .moveDown();
    }
  }

  private static addDigitalTwinContent(
    doc: PDFKit.PDFDocument,
    stepName: string,
    data: Record<string, any>
  ) {
    doc
      .fontSize(12)
      .font('Helvetica')
      .text('Digital Twin Report')
      .moveDown();

    if (data.metrics) {
      doc.fontSize(12).font('Helvetica-Bold').text('Performance Metrics').moveDown(0.5);
      Object.entries(data.metrics).forEach(([key, value]) => {
        doc
          .fontSize(11)
          .font('Helvetica')
          .text(`${key}: ${value}`)
          .moveDown(0.3);
      });
    }
  }

  /**
   * Generate Excel Spreadsheet
   */
  private static async generateSpreadsheet(
    config: DeliverableConfig
  ): Promise<GeneratedDeliverable> {
    // TODO: Implement Excel generation using exceljs
    const filename = `${config.deliverableType.replace(/\s+/g, '_')}_${Date.now()}.xlsx`;
    const filepath = join(this.outputDir, filename);

    // For now, return placeholder
    return {
      filename,
      filepath,
      url: `/api/deliverables/${filename}`,
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      size: 0,
      createdAt: new Date(),
    };
  }

  /**
   * Generate Canvas (Business Model Canvas, Value Proposition Canvas, etc.)
   */
  private static async generateCanvas(
    config: DeliverableConfig
  ): Promise<GeneratedDeliverable> {
    // Generate visual canvas as PDF
    return this.generateReport(config);
  }

  /**
   * Generate Document (Word-style document)
   */
  private static async generateDocument(
    config: DeliverableConfig
  ): Promise<GeneratedDeliverable> {
    // Generate document as PDF
    return this.generateReport(config);
  }

  /**
   * Get deliverable by filename
   */
  static async getDeliverable(filename: string): Promise<string> {
    return join(this.outputDir, filename);
  }

  /**
   * List all deliverables for a workflow
   */
  static async listDeliverables(workflowId: string): Promise<GeneratedDeliverable[]> {
    return [];
  }
}
